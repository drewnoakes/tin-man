/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/
-->begin
using System;

-->namespace
[System.Diagnostics.DebuggerNonUserCode]
[System.CodeDom.Compiler.GeneratedCode("CoCo/R", "1")]
internal sealed class Parser {
-->constants
    private const bool T = true;
    private const bool x = false;
    private const int minErrDist = 2;
    
    public Scanner scanner;
    public Errors  errors;

    public Token t;    // last recognized token
    public Token la;   // lookahead token
    private int errDist = minErrDist;

-->declarations

    public Parser(Scanner scanner) {
        this.scanner = scanner;
        errors = new Errors();
    }

    private void SynErr (int n) {
        if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
        errDist = 0;
    }

    public void SemErr (string msg) {
        if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
        errDist = 0;
    }
    
    private void Get () {
        for (;;) {
            t = la;
            la = scanner.Scan();
            if (la.kind <= maxT) { ++errDist; break; }
-->pragmas
            la = t;
        }
    }
    
    private void Expect (int n) {
        if (la.kind==n) Get(); else { SynErr(n); }
    }
    
    private bool StartOf (int s) {
        return set[s, la.kind];
    }
    
    private void ExpectWeak (int n, int follow) {
        if (la.kind == n) Get();
        else {
            SynErr(n);
            while (!StartOf(follow)) Get();
        }
    }

    private bool WeakSeparator(int n, int syFol, int repFol) {
        int kind = la.kind;
        if (kind == n) {Get(); return true;}
        else if (StartOf(repFol)) {return false;}
        else {
            SynErr(n);
            while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
                Get();
                kind = la.kind;
            }
            return StartOf(syFol);
        }
    }

-->productions

    public void Parse() {
        la = new Token();
        la.val = "";        
        Get();
-->parseRoot
    Expect(0);
    }
    
    static readonly bool[,] set = {
-->initialization
    };
} // end Parser

[System.Diagnostics.DebuggerNonUserCode]
[System.CodeDom.Compiler.GeneratedCode("CoCo/R", "1")]
public struct ParseError {
    public int LineNumber { get; private set; }
    public int ColumnNumber { get; private set; }
    public int ErrorCode { get; private set; }
    public string Message { get; private set; }
    
    public ParseError(int line, int col, int code, string message) : this()
    {
        LineNumber = line;
        ColumnNumber = col;
        ErrorCode = code;
        Message = message;
    }

    public override string ToString() {
        var m = new System.Text.StringBuilder();
        m.Append(Message);
        bool hasInfo = LineNumber!=-1 || ColumnNumber!=-1 || ErrorCode!=-1;
        bool infoYet = false;
        if (hasInfo)
            m.Append(" (");
        if (LineNumber!=-1) {
            m.Append("line " + LineNumber);
            infoYet = true;
        }
        if (ColumnNumber!=-1) {
            if (infoYet) m.Append(", ");
            m.Append("col " + ColumnNumber);
            infoYet = true;
        }
        if (ErrorCode!=-1) {
            if (infoYet) m.Append(", ");
            m.Append("code " + ErrorCode);
        }
        if (hasInfo)
            m.Append(')');
        return m.ToString();
    }
}

[System.Diagnostics.DebuggerNonUserCode]
[System.CodeDom.Compiler.GeneratedCode("CoCo/R", "1")]
public sealed class Errors {
    public List<ParseError> Items;
    public bool HasError { get { return Items!=null; } }
    public string ErrorMessages {
        get {
            if (Items==null) return null;
            var s = new System.Text.StringBuilder();
            foreach (var item in Items)
                s.AppendLine(item.ToString());
            return s.ToString();
        }
    }

    public void SynErr(int line, int col, int n) {
        string s;
        switch (n) {
-->errors
            default: s = "error code " + n; break;
        }
        
        AddError(line, col, n, s);
    }

    private void AddError(int line, int col, int code, string message) {
        if (Items==null)
            Items = new List<ParseError>();
        
        Items.Add(new ParseError(line, col, code, message));
    }

    public void SemErr(int line, int col, string s) {
        AddError(line, col, -1, s);
    }
    
    public void SemErr(string s) {
        AddError(-1, -1, -1, s);
    }
    
    public void Warning(int line, int col, string s) {
        // TODO should we record that this was a warning, and not an error?
        AddError(line, col, -1, s);
    }
    
    public void Warning(string s) {
        // TODO should we record that this was a warning, and not an error?
        AddError(-1, -1, -1, s);
    }
}


[System.Diagnostics.DebuggerNonUserCode]
[System.CodeDom.Compiler.GeneratedCode("CoCo/R", "1")]
public sealed class FatalError: Exception {
    public FatalError(string m): base(m) {}
}

$$$